---
layout: single
title:  "[23년 동계 대학생 S/W 알고리즘] 3. 연결 리스트"
---

[기초 강의](https://swexpertacademy.com/main/learn/course/subjectDetail.do?courseId=CONTENTS_REVIEW&subjectId=AYVXaMEKQSIDFARs)

연결 리스트
===
Linked List 개념 설명 및 종류
---

- 데이터가 자료의 주소 값으로 서로 연결(Link)되어 있는 구조
- **단순 연결 리스트(Singly Linked-list)**, **이중 연결 리스트(Doubly Linked-list)**, **원형 연결 리스트(Circular Linked-list)** 등의 구조가 있다.
- Array와 비교 및 계산 복잡도   

||Array|Linked List|
|:--:|--|--|
|**장점**|무작위 접근 가능|빠른 자료 삽입, 삭제<br>자유로운 크기 조절|
|**단점**|느린 자료 삽입, 삭제<br>크기 조절 불가능|순차 접근만 가능<br>메모리 추가 할당|

|Operation|Time complexity|
|--|--|
|**Access i-th element**|O(N)|
|**Insert element at here**|O(1)|
|**Delete element**|O(N)(search time)|

### 1. 단순 연결 리스트(Singly Linked List)
- 각 노드에서 단방향으로 연결되는 리스트
- **후행 노드는 쉽게 접근 가능하지만, 선행 노드는 접근이 복잡한 단점 존재**
<img src="https://github.com/Hyeon330/Hyeon330.github.io/blob/master/_img/post/2023_SamSung_DX_Algorithm/Linked_List/Singly_Linked-List.jpg?raw=true"/>


### 2. 이중 연결 리스트(Doubly Linked List)
- 각 노드에서 양방향(선행, 후행)으로 연결되는 리스트
- **양 방향 접근이 용이하지만, 메모리를 추가적으로 사용**
<img src="https://github.com/Hyeon330/Hyeon330.github.io/blob/master/_img/post/2023_SamSung_DX_Algorithm/Linked_List/Doubly_Linked-List.jpg?raw=true"/>


### 3. 원형 연결 리스트(Circular Linked List)
- 각 노드에서 단방향으로 진행되는 리스트
- 한 노드에서 모든 노드로 접근이 가능
<img src="https://github.com/Hyeon330/Hyeon330.github.io/blob/master/_img/post/2023_SamSung_DX_Algorithm/Linked_List/Circular_Linked-List.jpg?raw=true"/>

Linked List의 동작
---
### 데이터 삽입

<img src="https://github.com/Hyeon330/Hyeon330.github.io/blob/master/_img/post/2023_SamSung_DX_Algorithm/Linked_List/insert.jpg?raw=true"/>


### 데이터 삭제

<img src="https://github.com/Hyeon330/Hyeon330.github.io/blob/master/_img/post/2023_SamSung_DX_Algorithm/Linked_List/delete.jpg?raw=true"/>

정적 할당을 사용한 Linked List 구현
---

>메모리 풀(memory pool)을 통한 정적 할당 연결 리스트

```cpp
// Singly Linked List Node
struct Node {
    int data;
    Node* next;
};

// 1. 동적 할당 방식
Node* new_node(int data) {
    Node* node = new Node;

    node->data = data;
    node->next = nullptr;

    return node;
}

// 2. 정적 할당(메모리 풀) 방식
constexpr size_t MAX_NODE = 10000;

int node_count = 0;
Node node_poll[MAX_NODE];

Node* new_node(int data) {
    node_pool[node_count].data = data;
    node_pool[node_count].next = nullptr;

    return &node_pool[node_count++];
}
```
메모리 풀은 사용될 노드를 한 번에 모두 할당 한다음, 필요할 떄마다 하나씩 꺼내 쓰는 방식이다.

#### 메모리 풀의 장점

    1. 동적 할당을 하는 오버헤드가 없어진다.
    2. 사용이 끝날 때마다(특히 여러 개의 테스트 케이스가 있는 경우) 메모리를 해제할 필요가 없다.
    3. 모든 노드가 메모리 상에서 뭉쳐 있기 때문에 캐시 효율이 높아진다.

>실제로 프로그램을 개발할 떄는 동적 할당을 써야 하지만, 알고리즘 문제를 풀 때는 이러한 정적 할당을 쓰는 것이 수행 시간에 있어서 더 유리하다.

### 초기화
```cpp
Node head;

void init() {
    head.next = nullptr;
}
```