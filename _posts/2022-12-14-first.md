---
layout: single
title:  "STL"
---
Sequence Containers
---
- **Sequence Containers**는 데이터를 **순차적으로 저장**하는 자료구조 이다.
- 구현이 단순하므로 가볍고 빠르다.
- 저장할 데이터가 정렬 상태를 계속 유지할 필요가 없다면 사용하기 좋다.

### 1. vector(array)
메모리 상에서 데이터가 연속적으로 위치하는 배열

vector의 경우 배열의 크기를 런타임에서 조절할 수 있지만 array의 크기는 컴파일 타임에 결정되어야 하고 런타임에서 바꿀 수 없다. 사용할 배열의 크기를 미리 알 수 있고 크기가 변하지 않는다면 array를, 그렇지 않다면 vector를 선택한다.

vector는 포인터 세 개로 구현되어 있다.

    1. 할당된 배열의 시작 주소를 가리키는 포인터
    2. 다음에 데이터가 삽입될 위치를 가리키는 포인터
    3. 할당된 배열의 끝 주소를 가리키는 포인터
데이터를 뒤에 삽입하면 2번 포인터가 가리키는 곳에 삽입되고, 2번 포인터가 1증가한다.

##### vector 데이터 삽입 시 주의사항
>일반적으로 데이터를 뒤에 삽입하는 push_back연산은 **상수 시간복잡도**를 가지지만, 할당된 공간이 전부 차면 배열을 통쨰로 복사해 새로운 vector에 할당하는 reallocation이 발생해 시간이 많이 소요된다. 따라서, 알고리즘 문제 풀이 시에는 가급적 vector의 size를 충분히 확보한 상태로 사용하는 것이 좋다.

##### 예시 코드:
- **cpp**
```cpp
vector<int> array(8, 1);
cout << array.capacity() << endl;
array.push_back(2); // Reallocation happens
cout << array.capacity() << endl;
```
용량이 8인 vector가 전부 차있는 상태에서 push_back을 하면, vector 재할당이 일어나고, vector의 용량이 12로 변경된 것을 확인할 수 있다.
- **JAVA**
```java
public static void main(String[] args) {
    Vector<Integer> v = new Vector<>(3);
    System.out.println(v.capacity());   // 3
    for (int i = 0; i < v.capacity(); i++)
        v.add(i);
    System.out.println(v.capacity());   // 3
    v.add(1);   // Reallocation happens
    System.out.println(v.capacity());   // 6
}
```
java는 Reallocation이 발생하면 capacity가 2배씩 늘어난다.
>**참고**
해당 내용에 더하여, C++0x 에서부터는 백터의 길이가 늘어날 때 원소를 하나하나 복사하는 것이 아닌 우측 값 참조(메모리상에서의 이동)으로 이루어지는 성능 향상이 있다.

### 2. Deque