---
layout: single
title:  "(Samsung DX)STL"
---
Sequence Containers
---
- **Sequence Containers**는 데이터를 **순차적으로 저장**하는 자료구조 이다.
- 구현이 단순하므로 가볍고 빠르다.
- 저장할 데이터가 정렬 상태를 계속 유지할 필요가 없다면 사용하기 좋다.

### 1. vector(array)
메모리 상에서 데이터가 연속적으로 위치하는 배열

vector의 경우 배열의 크기를 런타임에서 조절할 수 있지만 array의 크기는 컴파일 타임에 결정되어야 하고 런타임에서 바꿀 수 없다. **사용할 배열의 크기를 미리 알 수 있고 크기가 변하지 않는다면 array를, 그렇지 않다면 vector를 선택한다.**

vector는 포인터 세 개로 구현되어 있다.

    1. 할당된 배열의 시작 주소를 가리키는 포인터
    2. 다음에 데이터가 삽입될 위치를 가리키는 포인터
    3. 할당된 배열의 끝 주소를 가리키는 포인터

데이터를 뒤에 삽입하면 2번 포인터가 가리키는 곳에 삽입되고, 2번 포인터가 1증가한다.

#### vector 데이터 삽입 시 주의사항
>일반적으로 데이터를 뒤에 삽입하는 push_back연산은 **상수 시간복잡도**를 가지지만, 할당된 공간이 전부 차면 배열을 통쨰로 복사해 새로운 vector에 할당하는 reallocation이 발생해 시간이 많이 소요된다. 따라서, 알고리즘 문제 풀이 시에는 가급적 vector의 size를 충분히 확보한 상태로 사용하는 것이 좋다.

##### 예시 코드:
- **cpp**
```cpp
vector<int> array(8, 1);
cout << array.capacity() << endl;
array.push_back(2); // Reallocation happens
cout << array.capacity() << endl;
```
용량이 8인 vector가 전부 차있는 상태에서 push_back을 하면, vector 재할당이 일어나고, vector의 용량이 12로 변경된 것을 확인할 수 있다.
- **JAVA**
```java
public static void main(String[] args) {
    Vector<Integer> v = new Vector<>(3);
    System.out.println(v.capacity());   // 3
    for (int i = 0; i < v.capacity(); i++)
        v.add(i);
    System.out.println(v.capacity());   // 3
    v.add(1);   // Reallocation happens
    System.out.println(v.capacity());   // 6
}
```
java는 Reallocation이 발생하면 capacity가 2배씩 늘어난다.
>**참고**   
C++0x 에서부터는 백터의 길이가 늘어날 때 원소를 하나하나 복사하는 것이 아닌 우측 값 참조(메모리상에서의 이동)으로 이루어지는 성능 향상이 있다.

### 2. Deque
Container 앞, 뒤에 데이터를 빠르게 넣고 뺄 수 있는 double-ended queue이다.

deque는 여러 개의 버퍼에 데이터를 나눠서 저장한다. vector는 할당된 공간이 전부 차면 배열을 통째로 새로 할당하는 반면, deque는 버퍼 하나만 할당하면 되므로, 데이터 삽입이 언제든 O(1)이다. **컨테이너의 앞에 데이터를 삽입/삭제, 컨테이너의 뒤에 데이터 삽입/삭제의 기능이 동시에 필요한 경우** deque는 유용한 선택이다.

#### Vector vs Deque 추가적인 차이점
해당 내용만 보면 deque가 vector보다 대부분의 상황에서 유리해 보일 수 있다. 하지만 vector의 요소들은 메모리상에 연속적으로 존재하는 것이 보장되지만, deque는 메모리에서 요소들이 연속적이지 않다. 따라서 C배열의 라이브러리와 상호작용해야 하는 상황이거나, 공간지역성을 고려해야하는 상황에서 deque가 불리한 점이 있다.