---
layout: single
title:  "[23년 동계 대학생 S/W 알고리즘] 6. DP"
---

DP(Dynamic Programming)
===

- 그리디 알고리즘과 같이 <U>최적화 문제</U>를 해결하는 알고리즘
- Recursive + Memoization
- 점화식으로 표현 가능
- 먼저 작은 부분 문제들의 해를 구하고 이들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 문제를 해결하는 알고리즘

> 최적화 문제: 최적(최대값 이나 최소값 같은)값을 구하는 문제

### DP의 적용 조건
- 최적 부분문제 구조(Optimal substructure)
- 중복 부분문제 구조(Overlapping subproblems)

기본 예제
---

### 토끼 수 구하기
조건
- 첫 달에는 새로 태어난 토끼 한 쌍만이 존재한다.
- 두 달 이상이 된 토끼는 번식 가능하다.
- 번식 가능한 토끼 한 쌍은 매달 한 쌍을 낳는다.
- 토끼는 죽지 않는다.

풀이
- n번째 달에 a쌍의 토끼가 있었고
- 다음 n + 1 번째 달에는 새로 태어난 토끼를 포함해 b쌍이 있었다고 하자.
- 그러면 그 다음 n + 2 번째 달에는 a + b쌍의 토끼가 있게 된다.
- 이는 n번째 달에 살아있던 토끼는 새끼를 낳을 수 있지만, 바로 전달인 n + 1번째에 막 태어난 토끼는 아직 새끼를 낳을 수 없기 때문이다.
```
f(n)을 n번째 달에 토끼 수라고 하면,
f(n + 2) = f(n) + f(n + 1) 이 성립한다.
피보나치 수열
```

재귀함수 구현
```cpp
fibo(n) {
    if (n < 2) return n
    return fibo(n - 1) + fibo(n - 2);
}
```
- 재귀로 풀이가 가능하다.
- 하지만 n의 수가 커질 수록 중복호출이 많아진다.
<img src="link">


수학적 귀납법
---

- 어떤 등식이 모든 n에 대해서 성립함을 보이기 위해서, 가능한 모든 n을 등식에 대입하여 증명할 수 는 없다.
- 주어진 등식이 n = 1일 때 성립함을 증명하고, n일 때 성립한다고 가정한 후, n + 1일 때 성립함을 증명한다.

### 증명 과정
    1. 귀납 기본(Induction base): n = 1 (혹은 n = 0)에 대해 등식이 성립함을 증명
    2. 귀납 가정(Induction hypothesis): 임의의 n에 대해 등식이 성립한다고 가정
    3. 귀납 단계(Induction step): 등식이 n + 1에 대해서도 성립함을 증명

### fibo(n)함수 호출 횟수 계산

- T(n) = fibo(n)을 계산하기 위하여 fibo() 함수를 호출하는 횟수
- T(n)은 재귀 트리 상의 마디의 수

<pre>
<code>조건: n >= 2, T(n - 1) > T(n - 2)
T(0) = 1;
T(1) = 1;
T(n) = T(n - 1) + T(n - 2) + 1
     > 2 * T(n - 2)
     > 2<sup>2</sup> * T(n - 4)
     > 2<sup>3</sup> * T(n - 6)
     ...
     > 2<sup>n/2</sup> * T(0) = 2<sup>n/2</sup></code>
</pre>

정리: 재귀적 알고리즘으로 구성한 재귀 트리의 마디 수를 n이라 하면, n >= 2인 모든 n에 대하여 T(n) > 2<sup>n/2</sup>이다.

증명: n에 대한 수학적 귀납법으로 증명
- Induction base:
>T(2) = T(1) + T(0) + 1 = 3 > 2 = 2<sup>2/2</sup>   
T(3) = T(2) + T(1) + 1 = 5 > 2.83 $\approx$ 2<sup>3/2</sup>

- Induction hypothesis:
> 2 <= m < n인 모든 m에 대해서 T(m) > 2<sup>m/2</sup>이라 가정

- Induction step:
> T(n) = T(n - 1) + (n - 2) + 1   
\> 2<sup>(n-1)/2</sup> + 2<sup>(n-2)/2</sup> + 1   
\> 2<sup>(n-2)/2</sup> + 2<sup>(n-2)/2</sup>   
= 2 * 2<sup>(n/2)-1</sup>   
= 2<sup>n/2</sup>